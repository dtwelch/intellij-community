package com.jetbrains.resolve.psi.impl;

import com.intellij.openapi.util.Computable;
import com.intellij.openapi.util.RecursionManager;
import com.intellij.openapi.util.TextRange;
import com.intellij.psi.PsiDirectory;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiReference;
import com.intellij.psi.ResolveState;
import com.intellij.psi.impl.source.resolve.reference.impl.providers.FileReferenceOwner;
import com.intellij.psi.impl.source.resolve.reference.impl.providers.PsiFileReference;
import com.intellij.psi.util.CachedValueProvider;
import com.intellij.psi.util.CachedValuesManager;
import com.intellij.psi.util.PsiModificationTracker;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.ObjectUtils;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.containers.Predicate;
import com.jetbrains.resolve.psi.*;
import com.jetbrains.resolve.psi.impl.imports.ResModuleLibraryReference;
import com.jetbrains.resolve.psi.impl.imports.ResModuleReference;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * Gathered from the language
 * <a href="https://confluence.jetbrains.com/display/IntelliJIDEA/PSI+Helpers+and+Utilities">tutorial</a>.
 * This util class is used internally by the grammarkit tool as a repository for "mixin" methods, which are essentially
 * handcoded methods that can be stuck into autogenerated {@link PsiElement}s.
 * <p>
 * Note that there's nothing inherently special going on here, this class just needs to be specified in the header of
 * a .bnf with the {@code psiImplUtilClass} property to be usable by grammarkit.</p>
 */
public class ResPsiImplUtil {

  @Nullable
  public static ResModuleLibraryIdentifier getFromLibraryIdentifier(@NotNull ResModuleIdentifierSpec moduleIdentifierSpec) {
    return moduleIdentifierSpec.getModuleLibraryIdentifier();
  }

  @Nullable
  private static PsiElement resolveModuleOrLibraryIdentifier(@NotNull PsiReference[] references,
                                                             @NotNull Predicate<PsiElement> p) {
    for (PsiReference reference : references) {
      if (reference instanceof FileReferenceOwner) {
        PsiFileReference lastFileReference = ((FileReferenceOwner)reference).getLastFileReference();
        PsiElement result = lastFileReference != null ? lastFileReference.resolve() : null;
        return p.apply(result) ? result : null;
      }
    }
    return null;
  }

  @NotNull
  public static TextRange getModuleIdentiferTextRange(@NotNull ResModuleIdentifier moduleIdentifier) {
    String text = moduleIdentifier.getText();
    return !text.isEmpty() ? TextRange.create(0, text.length() - 1) : TextRange.EMPTY_RANGE;
  }

  @NotNull
  public static TextRange getModuleLibraryIdentiferTextRange(@NotNull ResModuleLibraryIdentifier libraryIdentifier) {
    String text = libraryIdentifier.getText();
    return !text.isEmpty() ? TextRange.create(0, text.length() - 1) : TextRange.EMPTY_RANGE;
  }

  public static boolean shouldGoDeeper(@SuppressWarnings("UnusedParameters") ResModuleIdentifierSpec o) {
    return false;
  }

  @NotNull
  public static ResReference getReference(@NotNull ResReferenceExp o) {
    return new ResReference(o);
  }

  @NotNull
  public static ResMathVarLikeReference getReference(@NotNull ResMathReferenceExp o) {
    return new ResMathVarLikeReference(o);
  }

  @NotNull
  public static PsiReference[] getReferences(@NotNull ResModuleIdentifier o) {
    if (o.getTextLength() < 1) return PsiReference.EMPTY_ARRAY;
    return new ResModuleReference.ResModuleReferenceSet(o).getAllReferences();
  }

  @NotNull
  public static PsiReference[] getReferences(@NotNull ResModuleLibraryIdentifier o) {
    if (o.getTextLength() < 1) return PsiReference.EMPTY_ARRAY;
    return new ResModuleLibraryReference.ResModuleLibraryReferenceSet(o).getAllReferences();
  }

  @Nullable
  public static PsiElement resolve(@NotNull ResModuleIdentifier moduleIdentifier) {
    return resolveModuleOrLibraryIdentifier(moduleIdentifier.getReferences(), e -> e instanceof ResFile);
  }

  @Nullable
  public static PsiElement resolve(@NotNull ResModuleLibraryIdentifier libraryIdentifier) {
    return resolveModuleOrLibraryIdentifier(libraryIdentifier.getReferences(), e -> e instanceof PsiDirectory);
  }

  @Nullable
  public static PsiElement resolve(@NotNull ResReferenceExp o) {
    return o.getReference().resolve();
  }

  @NotNull
  public static String getName(@NotNull ResModuleIdentifierSpec moduleIdentifierSpec) {
    return moduleIdentifierSpec.getModuleIdentifier().getText();
  }

  @NotNull
  public static PsiElement getIdentifier(@NotNull ResModuleIdentifierSpec o) {
    return o.getModuleIdentifier();
  }

  @NotNull
  public static PsiElement getIdentifier(ResMathReferenceExp o) {
    return PsiTreeUtil.getChildOfType(o, ResMathSymbolName.class);
  }

  @Nullable
  public static ResReferenceExp getQualifier(@NotNull ResReferenceExp o) {
    return PsiTreeUtil.getChildOfType(o, ResReferenceExp.class);
  }

  @Nullable
  public static ResMathReferenceExp getQualifier(@NotNull ResMathReferenceExp o) {
    return PsiTreeUtil.getChildOfType(o, ResMathReferenceExp.class);
  }

  @NotNull
  public static ResType getUnderlyingType(@NotNull final ResType o) {
    ResType type = RecursionManager.doPreventingRecursion(o, true, new Computable<ResType>() {
      @Override
      public ResType compute() {
        return getTypeInner(o);
      }
    });
    return ObjectUtils.notNull(type, o);
  }

  @NotNull
  private static ResType getTypeInner(@NotNull ResType o) {
    if (o instanceof ResOperationLikeNode) {
      return o;
    }
    return o;
  }

  /**
   * An expression denoting the classification of a mathematical expression {@code o} written in terms of another
   * mathematical expression.
   */
  @Nullable
  public static ResMathExp getResMathMetaTypeExp(@NotNull final ResMathExp o,
                                                 @Nullable final ResolveState context) {
    return RecursionManager.doPreventingRecursion(
      o, true, new Computable<ResMathExp>() {
        @Override
        public ResMathExp compute() {
          if (context != null) return getResMathTypeMetaExpInner(o, context);
          return CachedValuesManager.getCachedValue(o, new CachedValueProvider<ResMathExp>() {
            @Override
            public Result<ResMathExp> compute() {
              return Result.create(getResMathTypeMetaExpInner(o, null),
                                   PsiModificationTracker.MODIFICATION_COUNT);
            }
          });
        }
      });
  }

  @Nullable
  public static ResMathExp getResMathTypeMetaExpInner(@NotNull final ResMathExp o, @Nullable ResolveState context) {
    if (o instanceof ResMathReferenceExp) {
      PsiReference reference = o.getReference();
      PsiElement resolve = reference != null ? reference.resolve() : null;
      if (resolve instanceof ResMathMetaTypeExpOwner) {
        return ((ResMathMetaTypeExpOwner) resolve).getResMathMetaTypeExp(context);
      }
    }
    else if (o instanceof ResMathSelectorExp) {
      ResMathExp item = ContainerUtil.getLastItem(((ResMathSelectorExp) o).getMathExpList());
      return item != null ? item.getResMathMetaTypeExp(context) : null;
    }
    return null;
  }
}
