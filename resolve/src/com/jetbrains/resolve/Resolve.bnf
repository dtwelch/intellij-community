{
    parserClass='com.jetbrains.resolve.parser.ResParser'

    implements='com.jetbrains.resolve.psi.ResCompositeElement'
    extends='com.jetbrains.resolve.psi.impl.ResCompositeElementImpl'

    elementTypeHolderClass='com.jetbrains.resolve.ResTypes'
    elementTypeClass='com.jetbrains.resolve.psi.ResCompositeElementType'
    tokenTypeClass='com.jetbrains.resolve.psi.ResTokenType'

    psiClassPrefix='Res'
    psiImplClassSuffix='Impl'
    psiPackage='com.jetbrains.resolve.psi'
    psiImplPackage='com.jetbrains.resolve.psi.impl'
    psiImplUtilClass="com.jetbrains.resolve.psi.impl.ResPsiImplUtil"

    tokens=[
        // Punctuation
        POUND   = '#'
        DOT     = '.'
        LPAREN  = '('
        RPAREN  = ')'
        PRIME   = '′'

        COLON       = ':'
        TRICOLON    = 'ː'
        COLON_COLON = '::'
        SEMICOLON   = ';'
        COMMA       = ','

        // Brackets
        DBL_BAR   = '∥'
        LANGLE    = '⟨'
        RANGLE    = '⟩'

        LCEIL = '⌈'
        RCEIL = '⌉'

        LBRACK = '['
        RBRACK = ']'

        DBL_LBRACE = '{{'
        DBL_RBRACE = '}}'

        LBRACE  = '{'
        RBRACE  = '}'
        BAR     = '|'

        // Builtin
        EXISTS = '∃'
        FORALL = '∀'
        LAMBDA = 'λ'
        TRI_EQUALS = '≜'
        COLON_EQUALS = ':='
        COLON_EQUALS_COLON = ':=:'
        BAD_CHARACTER = '"\\"'

        // TODO: These need to be declared in here because they begin with a capital letter... I need to ask about
        // this in grammarkit's issue section. But for now this is just the way it is.
        // Keywords (capitalized)
        CART_PROD     = 'Cart_Prod'
        //CATEGORICAL   = 'Categorical'
        //CONCEPT       = 'Concept'
        //COROLLARY     = 'Corollary'
        CHAINABLE     = 'Chainable'
        //DEFINES       = 'Defines'
        DEFINITION    = 'Definition'
        //ENHANCEMENT   = 'Enhancement'
        //FACILITY      = 'Facility'
        //IF_PROG       = 'If'
        IMPLICIT      = 'Implicit'
        //INDUCTIVE     = 'Inductive'
        OPERATION     = 'Operation'
        PRECIS        = 'Precis'
        //PROCEDURE     = 'Procedure'
        REALIZATION   = 'Realization'
        //RECOGNITION   = 'Recognition'
        //RECORD        = 'Record'
        //RECURSIVE     = 'Recursive'
        //THEOREM       = 'Theorem'
        //TYPE_FAMILY   = 'Type'
        TYPE_PARAM    = 'type'
        VALUED        = 'Valued'
        //VAR           = 'Var'
        //NOTICE        = 'Notice'
        //WHILE         = 'While'

        //these two are so grammarkit's live preview feature will work right,
        //disregard them otherwise
        space                   = "regexp:\s+"
        identifier              = 'regexp:\p{Alpha}\w*'
        int                     = 'int'
        char                    = 'char'
        raw_string              = 'raw_string'
    ]
    implements("Math.*DefnDecl")="com.jetbrains.resolve.psi.ResMathDefnDecl"
    implements(".*ModuleDecl")="com.jetbrains.resolve.psi.ResModuleDecl"
    implements("Math(Prefix|Infix|Outfix|Postfix)(DefnSig)")="com.jetbrains.resolve.psi.ResMathDefnSig"
    //implements("(Procedure|Operation)Decl|OperationProcedureDecl")="com.jetbrains.resolve.psi.ResOperationLikeNode"
    implements(".*ReferenceExp")="com.jetbrains.resolve.psi.ResReferenceExpBase"
    implements("(Spec|Realiz)ModuleParameters")="com.jetbrains.resolve.psi.ResModuleParameters"
    implements(".*((Var|Param|Field)Def|(MathTheorem|TypeParam|Exemplar|Facility)Decl|ModuleIdentifierSpec)")="com.jetbrains.resolve.psi.ResNamedElement"

    //implements("(TypeModel|TypeRepr)Decl")="com.jetbrains.resolve.psi.ResTypeLikeNodeDecl"
    implements(".*Block")="com.jetbrains.resolve.psi.ResBlock"

    extends("Math.*(DefnDecl)")="com.jetbrains.resolve.psi.impl.ResAbstractMathDefnImpl"
    extends("Math.*(Sig)")="com.jetbrains.resolve.psi.impl.ResAbstractMathSigImpl"
    extends(".*ModuleDecl")="com.jetbrains.resolve.psi.impl.ResAbstractModuleImpl"
    extends("MathVarDef")="com.jetbrains.resolve.psi.impl.ResMathNamedElementImpl"
    extends("Math.*(Exp)")=MathExp

    //extends("(Operation|Procedure|OperationProcedure)Decl")="edu.clemson.resolve.jetbrains.psi.impl.ResAbstractOperationLikeNode"
    extends("((Var|Param|Field)Def|(MathTheorem|TypeParam|Exemplar|Facility)Decl)|ModuleIdentifierSpec")="com.jetbrains.resolve.psi.impl.ResNamedElementImpl"
    //extends("(TypeModel|TypeRepr)Decl")="com.jetbrains.resolve.psi.impl.ResAbstractTypeDeclLikeNodeImpl"

    //pin(".*Statement")=1
    //extends(".*Statement")=Statement
    generateTokenAccessors=true
    pin('.*List(?:_\d.*)?')=1
}

ModuleDecl ::=
        PrecisModuleDecl
      | RealizationModuleDecl

PrecisModuleDecl ::= 'Precis' identifier (extends ReferenceExp)? ';'
UsesList?
PrecisBlock
end identifier ';' {pin(".*")=2}

RealizationModuleDecl ::= 'Realization' identifier RealizModuleParameters? for ReferenceExp (of ReferenceExp)? ';'
UsesList?
RequiresClause?
RealizBlock
end identifier ';' {pin(".*")=2}

// uses, imports

UsesList ::= uses UsesSpecs ';'  {pin(".*")=1}
private UsesSpecs ::= ModuleIdentifierSpec (',' ModuleIdentifierSpec)* {pin(".*")=1}

//shouldGoDeeper (impl sets to false) here allows us to avoid adding completions for ResModuleIdentifierSpec's
//there was an issue where qualifiers on math syms in say, global requires clauses, would resolve to a
//ModuleIdentifierSpec during the delegate's "treeWalkUp" phase -- leaving us with a ModuleIdentifierSpec, not a file..
//We don't want to resolve these until we're good and ready (i.e.: in {@link ResReference#processUsesImports})
ModuleIdentifierSpec ::= ModuleIdentifier [FromClause] {pin=1 methods=[getFromLibraryIdentifier getName getIdentifier shouldGoDeeper]}
private FromClause ::= from ModuleLibraryIdentifier {pin=1}

ModuleIdentifier ::= identifier {pin=1 methods=[getReferences getModuleIdentiferTextRange resolve]}
ModuleLibraryIdentifier ::= identifier ('.' identifier)* {pin(".*")=1 methods=[getReferences getModuleLibraryIdentiferTextRange resolve]}

// Module blocks & items

PrecisBlock ::= PrecisItem* {methods=[processDeclarations] recoverWhile=ItemsRecover}
RealizBlock ::= RealizItem* {methods=[processDeclarations] recoverWhile=ItemsRecover}
private ItemsRecover ::= !(end)

private RealizItem ::=
   /*   TypeReprDecl
    | OperationProcedureDecl
    | FacilityDecl
    | ProcedureDecl
    |*/ MathStandardDefnDecl {pin=1 recoverWhile=ImplItemRecover}

private ImplItemRecover ::= !(/*'Type'|'Operation'|'Facility'|'Recursive'|*/'Definition'|/*'Procedure'|*/end)


private PrecisItem ::=
          MathStandardDefnDecl
          //|MathTheoremDecl
        //| MathRecognitionDecl
        //| MathCategoricalDefnDecl
        /*| MathInductiveDefnDecl*/ {pin=1 recoverWhile=PrecisItemRecover}

private PrecisItemRecover ::= !('Definition'|'Implicit'/*|'Theorem'|'Corollary'|'Categorical'|'Inductive'|'Recognition'*/|'Chainable'|'Valued'|end)

// parameter and parameter-list related rules

/*
SpecModuleParameters ::= '(' SpecModuleParamList ')' {pin=1}
private SpecModuleParamList ::= SpecParamDecl  (';' SpecParamDecl)* {recoverWhile=ParamListRec}
private SpecParamDecl ::= TypeParamDecl | ParamDecl | MathStandardDefnDecl
*/

RealizModuleParameters ::= '(' ImplModuleParamList ')' {pin=1}
private ImplModuleParamList ::= ImplParamDecl  (';' ImplParamDecl)* {recoverWhile=ParamListRec}
private ImplParamDecl ::= ParamDecl//|OperationDecl

//private OperationLikeParameters ::= '(' OpParamList? ')' {pin=1}
//private OpParamList ::= ParamDecl (';' ParamDecl)* {pin=1 recoverWhile=ParamListRec}
ParamDecl ::= ParameterMode ParamDefinitionListNoPin /*':' Type*/ {pin=1}
private ParamDefinitionListNoPin ::= ParamDef &(!(';'|')')) (',' ParamDef)* {pin=1}
ParamDef ::= identifier

TypeParamDecl ::= 'type' identifier {pin=2}
ParameterMode ::= (alters|updates|clears|restores|preserves|replaces|evaluates|identifier)

// program variable decls


// facility decls


// statements


// program expressions

Exp ::= InfixExp | ParamExp | NestedExp | PrimeExp
{methods=[getResType] implements="com.jetbrains.resolve.psi.ResTypeOwner"}
fake BinaryExp ::= Exp+ { methods=[left="Exp[0]" right="Exp[1]"] extends=Exp}

NestedExp ::= '(' Exp ')'   {pin=1 extends=Exp}
SelectorExp ::= Exp '.' Exp {extends=BinaryExp}
InfixExp ::= Exp ProgSymbolName Exp {extends=BinaryExp}
ParamExp ::= NameExp ArgumentList {extends=Exp}
ProgSymbolName ::= (identifier|symbol)

NameExp ::= ReferenceExp QualifiedReferenceExp? {elementType=ReferenceExp}
left QualifiedReferenceExp ::= '::' identifier {elementType=ReferenceExp}
ReferenceExp ::= identifier { methods=[getReference getQualifier resolve shouldReferenceModule] extends=Exp}

private PrimeExp ::= LiteralExp | SelectorExp | NameExp
LiteralExp ::= (int|string|true|false)  {extends=Exp}
ArgumentList ::= '(' ExpArgumentList? ')' {pin=1}
private ExpArgumentList ::= Exp (',' Exp)* {pin(".*")=1}

// math constructs

/*MathTheoremDecl ::= ('Corollary'|'Theorem') identifier ':' MathAssertionExp ';' {pin = 2}
MathRecognitionDecl ::= 'Recognition' MathAssertionExp ';' {pin=1}
*/
MathStandardDefnDecl ::= ('Chainable')? ('Valued')? ('Implicit'?) 'Definition'  MathDefnSig ('≜' MathAssertionExp)? ';' {pin=4}

private MathDefnSig ::= MathPrefixDefnSig
MathPrefixDefnSig ::= MathPrefixNameList MathDefinitionParams? (':'|'ː') MathExp {pin=1}

private MathPrefixNameList ::= MathSymbolName (',' MathSymbolName)* {recoverWhile=MathPrefixListRec}
private MathPrefixListRec ::= !(':'|'ː'|';'|'(')
//private MathPrefixDefnSigs ::= MathPrefixDefnSig (',' MathPrefixDefnSig)* {recoverWhile=CategoricalSigListRec}
//private CategoricalSigListRec ::= !(is)

private MathDefinitionParams ::= '(' MathDefnParamList ')' { pin=1}
private ParamListRec ::= !(')'|';')
private MathDefnParamList ::= MathVarDeclGroup (',' MathVarDeclGroup)* {pin=1 recoverWhile=ParamListRec}

// mathematical variables

MathVarDeclGroup ::= MathVarDeclList (':'|'ː') MathExp {pin=1}

MathVarDecl ::= MathVarDef (':'|'ː') MathExp {pin=2 extends=MathVarDeclGroup}
private MathVarDeclList ::= MathVarDef &(!(')')) (',' MathVarDef)* {pin=1}
MathVarDef ::= MathSymbolName //TODO: Make this a MathSymbolName

// mathematical clauses

//IntializationClause ::= initialization (EnsuresClause) ;
RequiresClause ::= requires MathAssertionExp (EntailsClause)? ';' {pin=1}
/*EnsuresClause ::= ensures MathAssertionExp ';' {pin=1}
ConstraintsClause ::= constraints MathAssertionExp ';' {pin=1}
ConventionsClause ::= conventions MathAssertionExp (EntailsClause)? ';' {pin=1}
CorrespondenceClause ::= correspondence MathAssertionExp ';' {pin=1}
ChangingClause ::= changing ExpArgumentList ';' {pin=1}
MaintainingClause ::= maintaining MathAssertionExp ';' {pin=1}
DecreasingClause ::= decreasing MathAssertionExp ';' {pin=1}*/
EntailsClause ::= which_entails MathExp {pin=1}

// mathematical expressions

MathAssertionExp ::= MathQuantifiedExp | MathExp
MathQuantifiedExp ::= ('∃'|'∀') MathVarDeclGroup ',' MathAssertionExp {pin=1}

MathExp ::=
          MathInfixApplyExp
        | MathPrefixApplyExp
        | MathMixfixApplyExp
        | MathNestedExp
        | MathPrimeExp {methods=[getResMathMetaTypeExp]}

MathNestedExp ::= '(' MathAssertionExp ')' {pin=1}
MathSelectorExp ::= MathExp '.' MathExp
MathPrefixApplyExp ::= MathExp MathFunctionAppList
MathMixfixApplyExp ::= MathExp MathBracketName MathNonStdAppList MathBracketName {pin=4}
MathOutfixApplyExp ::=  MathOutfixAppList
MathInfixApplyExp ::= MathExp MathOpSymbolName MathExp {pin=2}
MathClssftnAssrtExp ::= MathExp (':'|'ː') MathExp
MathIncomingExp ::= '#' MathSymbolExp {pin=1}

MathFunctionAppList ::= '(' MathArgList ')'
private MathOutfixAppList ::= MathBracketName MathNonStdAppList MathBracketName {pin=3}
private MathNonStdAppList ::= MathExp (',' MathExp)* {pin=1}
private MathArgList ::= MathExp (',' MathExp)* {pin=1 recoverWhile=ParamListRec}

private MathPrimeExp ::= MathIncomingExp | MathSymbolExp | MathSelectorExp | MathLambdaExp
        | MathAlternativeExp
        | MathClssftnAssrtExp
        | MathOutfixApplyExp
        | MathCartProdExp
        | MathBigUnionExp
     //   | MathSetExp
     //   | MathSetRestrictionExp

private MathOpSymbolName ::= MathSymbolExp
MathBracketName ::= ('⟨'|'⟩'|'⌈'|'⌉'|'∥'|'['|']'|'|'|'{'|'}') {elementType=MathSymbolName}
MathSymbolName  ::= (identifier|int|symbol|mathsymbol|true|false)

MathSymbolExp ::=  MathReferenceExp MathQualifiedReferenceExp? {elementType=MathReferenceExp}
left MathQualifiedReferenceExp ::= '::' MathSymbolName {elementType=MathReferenceExp}
MathReferenceExp ::= MathSymbolName {methods=[getReference getQualifier getIdentifier] extends=MathExp}

MathCartProdExp ::= 'Cart_Prod' ResMathCartVarGroup+  end {pin=1}
private ResMathCartVarGroup ::= MathVarDeclGroup ';' {pin=1}
MathLambdaExp ::= 'λ' MathVarDecl ','  MathExp {pin=1}
MathAlternativeExp ::= '{{' MathAlternativesList '}}' {pin=1}
MathAlternativesList ::= MathAlternativeItemExp+
MathAlternativeItemExp ::= MathExp (if MathExp ';' | otherwise ';')
//MathSetRestrictionExp ::= '{' MathVarDecl '|' MathExp '}' {pin=1}
MathBigUnionExp ::= bigoperator MathVarDecl ',' MathExp