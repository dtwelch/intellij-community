{
    parserClass='com.jetbrains.resolve.parser.ResParser'

    implements='com.jetbrains.resolve.psi.ResCompositeElement'
    extends='com.jetbrains.resolve.psi.impl.ResCompositeElementImpl'

    elementTypeHolderClass='com.jetbrains.resolve.ResTypes'
    elementTypeClass='com.jetbrains.resolve.psi.ResCompositeElementType'
    tokenTypeClass='com.jetbrains.resolve.psi.ResTokenType'

    psiClassPrefix='Res'
    psiImplClassSuffix='Impl'
    psiPackage='com.jetbrains.resolve.psi'
    psiImplPackage='com.jetbrains.resolve.psi.impl'
    psiImplUtilClass="com.jetbrains.resolve.psi.impl.ResPsiImplUtil"

    tokens=[
        // Punctuation
        POUND   = '#'
        DOT     = '.'
        LPAREN  = '('
        RPAREN  = ')'
        PRIME   = '′'

        COLON       = ':'
        TRICOLON    = 'ː'
        COLON_COLON = '::'
        SEMICOLON   = ';'
        COMMA       = ','

        // Brackets
        DBL_BAR   = '∥'
        LANGLE    = '⟨'
        RANGLE    = '⟩'

        LCEIL = '⌈'
        RCEIL = '⌉'

        LBRACK = '['
        RBRACK = ']'

        DBL_LBRACE = '{{'
        DBL_RBRACE = '}}'

        LBRACE  = '{'
        RBRACE  = '}'
        BAR     = '|'

        // Builtin
        EXISTS = '∃'
        FORALL = '∀'
        LAMBDA = 'λ'
        TRI_EQUALS = '≜'
        COLON_EQUALS = ':='
        COLON_EQUALS_COLON = ':=:'
        BAD_CHARACTER = '"\\"'

        // TODO: These need to be declared in here because they begin with a capital letter... I need to ask about
        // this in grammarkit's issue section. But for now this is just the way it is.
        // Keywords (capitalized)
        /*CART_PROD     = 'Cart_Prod'
        CATEGORICAL   = 'Categorical'
        CONCEPT       = 'Concept'
        COROLLARY     = 'Corollary'
        CHAINABLE     = 'Chainable'
        DEFINES       = 'Defines'
        DEFINITION    = 'Definition'
        ENHANCEMENT   = 'Enhancement'
        FACILITY      = 'Facility'
        IF_PROG       = 'If'
        IMPLICIT      = 'Implicit'
        INDUCTIVE     = 'Inductive'
        OPERATION     = 'Operation'*/
        PRECIS        = 'Precis'
        /*PROCEDURE     = 'Procedure'
        REALIZATION   = 'Realization'
        RECOGNITION   = 'Recognition'
        RECORD        = 'Record'
        RECURSIVE     = 'Recursive'
        THEOREM       = 'Theorem'
        TYPE_FAMILY   = 'Type'
        TYPE_PARAM    = 'type'
        VALUED        = 'Valued'
        VAR           = 'Var'
        NOTICE        = 'Notice'
        WHILE         = 'While'*/

        //these two are so grammarkit's live preview feature will work right,
        //disregard them otherwise
        space                   = "regexp:\s+"
        identifier              = 'regexp:\p{Alpha}\w*'
        int                     = 'int'
        char                    = 'char'
        raw_string              = 'raw_string'
    ]
    implements(".*ReferenceExp")="com.jetbrains.resolve.psi.ResReferenceExpBase"
    implements(".*ModuleDecl")="com.jetbrains.resolve.psi.ResModuleDecl"

    extends(".*ModuleDecl")="com.jetbrains.resolve.psi.impl.ResAbstractModuleImpl"
    generateTokenAccessors=true
}

ModuleDecl ::=
      PrecisModuleDecl

//TODO: Instead to 'Precis' identifier (extends identifier)? ';' that is, combine the precisModuleDecl
//and PrecisExtensionModuleDecl.
PrecisModuleDecl ::= Precis identifier (for ReferenceExp)? ';'
UsesList?
//PrecisBlock
end identifier ';' {pin(".*")=2}

// uses, imports

UsesList ::= uses UsesSpecs ';'  {pin(".*")=1}
private UsesSpecs ::= ModuleIdentifierSpec (',' ModuleIdentifierSpec)* {pin(".*")=1}

//shouldGoDeeper (impl sets to false) here allows us to avoid adding completions for ResModuleIdentifierSpec's
//there was an issue where qualifiers on math syms in say, global requires clauses, would resolve to a
//ModuleIdentifierSpec during the delegate's "treeWalkUp" phase -- leaving us with a ModuleIdentifierSpec, not a file..
//We don't want to resolve these until we're good and ready (i.e.: in {@link ResReference#processUsesImports})
ModuleIdentifierSpec ::= ModuleIdentifier [FromClause] {pin=1 methods=[getFromLibraryIdentifier getName getIdentifier shouldGoDeeper]}
private FromClause ::= from ModuleLibraryIdentifier {pin=1}

ModuleIdentifier ::= identifier {pin=1 methods=[getReferences getModuleIdentiferTextRange resolve]}
ModuleLibraryIdentifier ::= identifier ('.' identifier)* {pin(".*")=1 methods=[getReferences getModuleLibraryIdentiferTextRange resolve]}

// Module blocks & items

/*PrecisBlock ::= PrecisItem* {methods=[processDeclarations] recoverWhile=ItemsRecover}

private ItemsRecover ::= !(end)

private PrecisItem ::=
          MathTheoremDecl
        //| MathRecognitionDecl
       // | MathStandardDefnDecl
        | MathCategoricalDefnDecl
        | MathInductiveDefnDecl {pin=1 recoverWhile=PrecisItemRecover}

private PrecisItemRecover ::= !('Definition'|'Implicit'|'Theorem'|'Corollary'|'Categorical'|'Inductive'|'Recognition'|'Chainable'|'Valued'|end)


// math constructs
MathTheoremDecl ::= ('Corollary'|'Theorem') identifier ':' MathAssertionExp ';' {pin = 2}
MathRecognitionDecl ::= 'Recognition' MathAssertionExp ';' {pin=1}
*/

// program expressions

Exp ::= InfixExp | ParamExp | NestedExp | PrimeExp
{methods=[getResType] implements="com.jetbrains.resolve.psi.ResTypeOwner"}
fake BinaryExp ::= Exp+ { methods=[left="Exp[0]" right="Exp[1]"] extends=Exp}

NestedExp ::= '(' Exp ')'   {pin=1 extends=Exp}
SelectorExp ::= Exp '.' Exp {extends=BinaryExp}
InfixExp ::= Exp ProgSymbolName Exp {extends=BinaryExp}
ParamExp ::= NameExp ArgumentList {extends=Exp}
ProgSymbolName ::= (identifier|symbol)

NameExp ::= ReferenceExp QualifiedReferenceExp? {elementType=ReferenceExp}
left QualifiedReferenceExp ::= '::' identifier {elementType=ReferenceExp}
ReferenceExp ::= identifier { methods=[getReference getQualifier resolve shouldReferenceModule] extends=Exp}

private PrimeExp ::= LiteralExp | SelectorExp | NameExp
LiteralExp ::= (int|string|true|false)  {extends=Exp}
ArgumentList ::= '(' ExpArgumentList? ')' {pin=1}
private ExpArgumentList ::= Exp (',' Exp)* {pin(".*")=1}